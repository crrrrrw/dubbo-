## 前言
dubbo框架也用了有一年了，一直没有详细的研究过dubbo源码。所以趁有时间好好学习体会dubbo的博大精深。本人才疏学浅，如有不对，请大神指点。

如何看源码？跟着[Dubbo开发手册(中文)](http://dubbo.apache.org/books/dubbo-dev-book/)来喽。带着目的看源码，这次看dubbo是怎么暴露服务的。


## 先瞜一眼启动日志
一般像这种大型的开源框架，都会有健全的启动日志，看看日志输出利于我们理解dubbo启动流程。
![](http://ww1.sinaimg.cn/large/87faef88ly1fqz30w0utyj21e70lftdv.jpg)
日志输出从上往下看，dubbo做了哪些事：
1. 暴露本地服务
2. 暴露远程服务
3. 启动Netty，绑定和暴露地址
4. 连接zookeeper
5. zookeeper订阅服务
6. 监听zookeeper

## 先瞜一眼官方手册
这段内容来自[dubbo开发手册之实现细节](http://dubbo.apache.org/books/dubbo-dev-book/implementation.html)

![](http://ww1.sinaimg.cn/large/87faef88ly1fqz3wdhv82j20ns0n7q8q.jpg)

再来一段暴露服务时序图
![image](http://dubbo.apache.org/books/dubbo-dev-book/sources/images/dubbo-export.jpg)

接下来，从官方文档开始，分析dubbo服务暴露过程。

## 第一步， ServiceConfig
分析前，先利用IDE生成类图看看ServiceConfig的继承关系。
![](http://ww1.sinaimg.cn/large/87faef88ly1fqzgb7myddj20tj0de754.jpg)


*问题一：这么多的配置是啥？*  
凭借感觉像是和dubbo.xml里的配置属性有关系。先不管，留个坑。

根据时序图，我们先定位到 ServiceConfig 的 export()方法
**ServiceConfig#export**
```java
public synchronized void export() {
    ...
    // 延迟暴露接口
    if (delay != null && delay > 0) {
        delayExportExecutor.schedule(new Runnable() {
            public void run() {
                doExport();
            }
        }, delay, TimeUnit.MILLISECONDS);
    } else {
        doExport(); // 此处调用开始暴露
    }
}
```
暴露服务是调用 **ServiceConfig#doExport**方法
```
protected synchronized void doExport() {
    if (unexported) {
        throw new IllegalStateException("Already unexported!");
    }
    if (exported) {
        return;
    }
    exported = true;
    if (interfaceName == null || interfaceName.length() == 0) {
        throw new IllegalStateException("<dubbo:service interface=\"\" /> interface not allow null!");
    }
    checkDefault();// 创建了 ProviderConfig 对象并赋值 setter is属性，提供者的缺省值设置
    /**
     * provider已经配置的情况下，application、module、registries、monitor、protocol中未配置的值均可以从provider获取
     */
    if (provider != null) {
        if (application == null) {
            application = provider.getApplication();
        }
        if (module == null) {
            module = provider.getModule();
        }
        if (registries == null) {
            registries = provider.getRegistries();
        }
        if (monitor == null) {
            monitor = provider.getMonitor();
        }
        if (protocols == null) {
            protocols = provider.getProtocols();
        }
    }
    if (module != null) {
        if (registries == null) {
            registries = module.getRegistries();
        }
        if (monitor == null) {
            monitor = module.getMonitor();
        }
    }
    if (application != null) {
        if (registries == null) {
            registries = application.getRegistries();
        }
        if (monitor == null) {
            monitor = application.getMonitor();
        }
    }
    if (ref instanceof GenericService) {
        interfaceClass = GenericService.class;
        if (StringUtils.isEmpty(generic)) {
            generic = Boolean.TRUE.toString();
        }
    } else {
        try {
            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()
                    .getContextClassLoader());
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        checkInterfaceAndMethods(interfaceClass, methods); // 检查配置中的 interface 属性 和 methods属性
        checkRef();  // 检查 ref 属性
        generic = Boolean.FALSE.toString();
    }
    // 如果配置 local 属性， 是否服务接口客户端本地代理
    if (local != null) {
        if ("true".equals(local)) {
            local = interfaceName + "Local";
        }
        Class<?> localClass;
        try {
            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        if (!interfaceClass.isAssignableFrom(localClass)) {
            throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceName);
        }
    }
    // 如果配置 stub 属性， 是否本地存根 
    if (stub != null) {
        if ("true".equals(stub)) {
            stub = interfaceName + "Stub";
        }
        Class<?> stubClass;
        try {
            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        if (!interfaceClass.isAssignableFrom(stubClass)) {
            throw new IllegalStateException("The stub implementation class " + stubClass.getName() + " not implement interface " + interfaceName);
        }
    }
    checkApplication(); // 检查 application 属性
    checkRegistry(); // 检查 registry 属性
    checkProtocol(); // 检查 protocol 属性
    appendProperties(this); // 赋值 ServiceConfig setter is 属性
    checkStubAndMock(interfaceClass); // 检查是否 使用 local,stub,mock 代理
    if (path == null || path.length() == 0) {
        path = interfaceName;
    }
    doExportUrls(); // 开始暴露远程服务了
    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);
    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);
}
```
**ServiceConfig#doExportUrls**暴露多个远程地址
```
private void doExportUrls() {
    // dubbo支持多注册中心，所以这一步把 registry 配置信息封装为多个url,比如 registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider...
    List<URL> registryURLs = loadRegistries(true);
    // dubbo是支持多协议的，将所有注册的url上对应的协议暴露出来
    for (ProtocolConfig protocolConfig : protocols) {
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
```
**ServiceConfig#doExportUrlsFor1Protocol**暴露单个地址
```
private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
    String name = protocolConfig.getName();
    if (name == null || name.length() == 0) {
        name = "dubbo";
    }

    // map存放所有配置参数，下面生成url用
    Map<String, String> map = new HashMap<String, String>();
    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);
    map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());
    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
    if (ConfigUtils.getPid() > 0) {
        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));
    }
    appendParameters(map, application);
    appendParameters(map, module);
    appendParameters(map, provider, Constants.DEFAULT_KEY);
    appendParameters(map, protocolConfig);
    appendParameters(map, this);
    // method子标签配置规则解析，暂时不管
    if (methods != null && !methods.isEmpty()) {
        for (MethodConfig method : methods) {
            ...
        } // end of methods for
    }

    // 获取所有方法添加到map中，体现在url里
    if (ProtocolUtils.isGeneric(generic)) { // 如果是泛化实现，generic属性为true，method=*表示任意方法
        map.put("generic", generic);
        map.put("methods", Constants.ANY_VALUE);
    } else {
        String revision = Version.getVersion(interfaceClass, version);
        if (revision != null && revision.length() > 0) {
            map.put("revision", revision);
        }

        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
        if (methods.length == 0) {
            logger.warn("NO method found in service interface " + interfaceClass.getName());
            map.put("methods", Constants.ANY_VALUE);
        } else {
            map.put("methods", StringUtils.join(new HashSet<String>(Arrays.asList(methods)), ","));
        }
    }
    // 如果配置了token属性，如果配为default则随机UUID，否则使用配置中的token，作令牌验证用
    if (!ConfigUtils.isEmpty(token)) {
        if (ConfigUtils.isDefault(token)) {
            map.put("token", UUID.randomUUID().toString());
        } else {
            map.put("token", token);
        }
    }
    // 如果协议是 injvm，就不注册服务， notify设置为false
    if ("injvm".equals(protocolConfig.getName())) {
        protocolConfig.setRegister(false);
        map.put("notify", "false");
    }
    // export service
    String contextPath = protocolConfig.getContextpath();
    // 如果 protocol配置没有配置contextPath属性，就从provider配置中取
    if ((contextPath == null || contextPath.length() == 0) && provider != null) {
        contextPath = provider.getContextpath();
    }

    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);
    Integer port = this.findConfigedPorts(protocolConfig, name, map);
    // 根据上面的参数创建url对象
    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? "" : contextPath + "/") + path, map);
    // 如果url使用的协议存在扩展，调用对应的扩展来修改原url。
    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
            .hasExtension(url.getProtocol())) {
        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
        }

        String scope = url.getParameter(Constants.SCOPE_KEY);
        // 如果scope属性没有配置为 none
        if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {

            // 如果scope属性没有配置为 remote， 暴露本地服务
            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {
                exportLocal(url);
            }
            // // 如果scope属性没有配置为 local， 暴露远程服务
            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {
                if (logger.isInfoEnabled()) {
                    logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
                }
                if (registryURLs != null && !registryURLs.isEmpty()) {
                    for (URL registryURL : registryURLs) {
                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));
                        URL monitorUrl = loadMonitor(registryURL);
                        if (monitorUrl != null) { // 如果有monitor信息，则在url上增加monitor配置
                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
                        }
                        if (logger.isInfoEnabled()) {
                            logger.info("Register dubbo service " + interfaceClass.getName() + " url " + url + " to registry " + registryURL);
                        }
                        // 重要的第二步了，创建 invoker 对象
                        Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
                        // 第三步，官方文档加重点的一步，invoker转化为 exporter
                        Exporter<?> exporter = protocol.export(wrapperInvoker);
                        exporters.add(exporter);
                    }
                } else {
                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

                    Exporter<?> exporter = protocol.export(wrapperInvoker);
                    exporters.add(exporter);
                }
            }
        }
        this.urls.add(url);
    }
```

## 第二步，ProxyFactory.getInvoker
在**ServiceConfig#doExportUrlsFor1Protocol**暴露单个地址中的调用:
```
Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
```
接下来看看这一行代码里做了什么。
![](http://ww1.sinaimg.cn/large/87faef88ly1fr2vg3gsllj20rw02n0t2.jpg)

*问题二：这个 ProxyFactory$Adaptive是什么东东？*
看看 proxyFactory 是怎么来的。
```
private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
```
看来是和这个 ExtensionLoader 有关。看看接口:
```
@SPI("javassist")
public interface ProxyFactory {
    @Adaptive({Constants.PROXY_KEY})
    <T> T getProxy(Invoker<T> invoker) throws RpcException;

    @Adaptive({Constants.PROXY_KEY})
    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;

}
```
@SPI 看起来和java SPI机制有关哦。先留个坑，回头再解决。

但是通过我们debug发现，默认情况下 ProxyFactory的实现是 JavassistProxyFactory。
```
public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
        return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }
```